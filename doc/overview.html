<html>
<body>

<h1 class="overview">User Guide</h1>

<strong>
Rainbow Gum: a modern logging implementation
</strong>
<p>
<em>
Fast, modern, GraalVM native friendly and easy to use.
</em>
</p>

<h2 class="toc-title">Contents</h2>

<nav class="js-toc"></nav>

<div class="js-toc-content">

<h2 id="gettingstarted">Getting Started</h2>


First step is to add <a href="#installation">Rainbow Gum as a dependency</a>. 
<p>
Second if you are not familiar with logging in the Java ecosystem please refer to
the excellent <a href="https://www.slf4j.org/manual.html">Logging facade SLF4J</a> documentation
particularly the <a href="https://www.slf4j.org/apidocs-2.1.0/org/slf4j/Logger.html">logger API</a>
and what logging Levels are. Logging levels are and how dotted logger names inherit levels is covered in
 the JDKs logging facade {@link java.lang.System.Logger.Level} as well as 
 <a href="https://logback.qos.ch/manual/architecture.html#effectiveLevel">Logback effective level</a>
 which Rainbow Gum follows.

</p>
The third step is to configure. Most configuration is just configuring logger names to levels, output, and formatting. 
We will cover the two major ways to do this in the following two sub sections.


<h3 id="simple_example">Using System properties</h3>

Assuming we have <a href="#installation">installed RainbowGum as a dependency</a> a simple configuration example using System Properties is below:

{@snippet :
  java \
  -Dlogging.appender.console.encoder=pattern \ 
  -Dlogging.encoder.console.pattern="[%thread] %-5level %logger{15} - %msg%n" \
  -Dlogging.level.com.myapp=DEBUG \
  myapp.jar 
}

What happens with the above is Rainbow Gum will load its default Rainbow Gum via the service loader and use the properties to configure
its builders. Unfortunately System properties on the command line can be rather tedious but luckily you
can plugin in your own properties system easily.

<h3 id="simple_example_builder">Using RainbowGum Builders</h3>

For organizations that have many projects it is recommended to use the programmatic builder approach and make a standardized jar (module)
shared between all your projects so that logging configuration is consistent.

Assuming we have <a href="#installation">installed RainbowGum as a dependency</a> a simple configuration example using
Java directly and the {@link java.util.ServiceLoader} is below. 

{@snippet class="snippets.GettingStartedExample" region="gettingStarted" }

{@link io.jstach.rainbowgum.spi.RainbowGumServiceProvider} has additional documentation on how to register
a service loader aware jar.

<h2 id="description">Description</h2>

Rainbow Gum is a modern opinionated SLF4J implementation that aims to be easier to use
while leveraging newer JDK technology.

Rainbow Gum unlike Logback or Log4J (2) does not offer as much flexibility but is simpler
and has less overhead.

The <a href="https://github.com/jstachio/rainbowgum">readme in the Rainbow Gum project</a> 
discusses more extensively on the opinionated design and philosophy.


<h2 id="project_information">Project Information</h2>

<dl class="notes">
  <dt>Source Control</dt>
  <dd><a href="https://github.com/jstachio/rainbowgum">https://github.com/jstachio/rainbowgum</a></dd>
  <dt>Team</dt>
  <dd>
    <ul>
      <li><a href="https://github.com/agentgt">Adam Gent (agentgt)</a> - lead</li>
    </ul>
  </dd>
  <dt>Issues</dt>
  <dd><a href="https://github.com/jstachio/jstachio/issues">https://github.com/jstachio/rainbowgum/issues</a></dd>
  <dt>Community</dt>
  <dd><a href="https://github.com/jstachio/jstachio/discussions">https://github.com/jstachio/rainbowgum/discussions</a></dd>
  <dt>User Guide</dt>
  <dd>
    <a href="index.html">This document</a>
  </dd>
  <dt>Javadoc</dt>
  <dd>
    <a href="#all-modules-table">This document (modules listing at bottom)</a>
  </dd>
</dl>

The project follows <a href="https://semver.org/">semantic versioning</a>.

<h3 id="requirements">Requirements</h3>

<ol>
  <li><a href="https://docs.oracle.com/en/java/javase/21/">Java 21 or greater</a></li>
  <li>A build system that supports running the Java compiler annotation processor</li>
</ol>

The only module needed during runtime is  
<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/module-summary.html">
  <code>java.base</code>
</a>

<h3 id="limitations">Limitations</h3>

Currently Rainbowgum does not provide support for:

<ul>
  <li>External config - by design you will need to bring your own configuration lib or just use env/system properties</li>
  <li>Rolling of log files. Possibly will be added in the future.</li>
 </ul>

<h2 id="how_it_works">How it works</h2>

Most users will use Rainbow Gum through a logging facade such as SLF4J and the only interaction with
Rainbow Gum is configuration of output and formatting. Rainbow Gum provides three ways to configure
out of the box:

<ul>
  <li>Programmatic Java configuration using builders.</li>
  <li>Simple String key/value properties often derived from System properties / env variables</li>
  <li>Dependency driven configuration where including a jar as dependency changes behavior automatically</li>
</ul>

In practice many will use a mixture of all three styles. Rainbow Gum uses the Service Loader to load "default" configurations. 
Other than logger levels most configuration is simply choosing which jars to be included at runtime and providing some
simple properties.


<h2 id="architecture">Architecture</h2>

Rainbow Gum's design has many superficial similarties to Logback, Log4j2, and Reload4j in that
there are Appenders and Encoders as well as how log levels are inherited but most of Rainbow Gum's design
is <em>very different!</em>.

<p>
  The major key difference in Rainbow Gum is that once configured and initialized the logging system is locked in and
  cannot be changed. Certain parts of the system can be changed at runtime but require opt-in which includes changing
  levels of logger names.
</p>
<p>
  Another major difference is that Rainbow Gum is highly modularized, immutable and componentized. In other frameworks
  OOP inheritance is heavily abused and riddled with state management. Furthermore there are components that
  have too much responsibility which is the case with Appenders in Logback or "Managers" in Log4j2.
  Furthermore Rainbow Gum avoids reflection other than the Service Loader and follows the builder pattern
  extensively to separate configuration from immutable runtime components. Almost all components have
  a builder to programmatically configure and the builders can take flat string key values as configuration. 
</p>
<p>
  The results of the above choices make Rainbow Gum far lighter than logback, log4j2, and reload4j particularly
  in initialization time as well as security surface area.
</p>

<strong>The key components expressed in the flow of log events is as follows:</strong>
<ol>
<li>Logging Facade (SLF4J)</li>
<li>{@link io.jstach.rainbowgum.RainbowGum}</li>
<li>{@link io.jstach.rainbowgum.LogRouter}</li>
<li>{@link io.jstach.rainbowgum.LogPublisher}</li>
<li>{@link io.jstach.rainbowgum.LogAppender}</li>
<li>{@link io.jstach.rainbowgum.LogEncoder}</li>
<li>{@link io.jstach.rainbowgum.LogOutput}</li>
</ol>

In the next sections we will cover  
<a href="#configuration">Configuration</a>, 
<a href="#publishers">Publishers</a>, 
<a href="#appenders">Appenders</a>, 
<a href="#encoders">Encoders</a>,
and 
<a href="#outputs">Outputs</a>.

For most <a href="#level_resolvers">level resolving</a>, <a href="#formatters">formatters</a> (which are simplified encoders),
and Outputs are the main points of interest in customizing and configuring.

<h2 id="config">Configuration</h2>

A defining characteristic of Rainbow Gum is that it does not have a special configuration format
like Logback, Log4j2, and Reload4j (all three use XML as the default). The expectation
is that for simple configuration {@linkplain io.jstach.rainbowgum.LogProperties simple properties interface} analogous to 
<code>Function&lt;String,String&gt;</code> is good enough. For more complicated configuration
programmatic configuration using the builders and service loader should be used.
<p>
  For implementers of plugins {@link io.jstach.rainbowgum.LogConfig } allows registering of services
  and plugins (it also contains the global {@link io.jstach.rainbowgum.LogProperties} ) however
  most users will not need to know about it. For those coming from Logback
  {@link io.jstach.rainbowgum.LogConfig } is analogous to what Logback calls "Context".
</p>

Rainbow Gum out of the box uses System properties for {@link io.jstach.rainbowgum.LogProperties}
but an optional module {@link io.jstach.rainbowgum.avaje/ } will allow using <a href="https://avaje.io/config/">Avaje Config</a>
as the properties provider. Other configuration systems will be added in the future but an 
important requirement is that these systems do not do any logging or if they do allow it to be
turned off, intercepted or blocked.

<h2 id="router">Router</h2>

A Router has a {@link io.jstach.rainbowgum.LevelResolver} and a Publisher.
A Level Resolver takes a logger name and produces a {@link java.lang.System.Logger.Level level}.
The logging facade implementation than decides based on the level whether or not to construct an event.
It then passes the event to the router which in turn uses the publisher to schedule the event.

For those familiar with other logging frameworks 
<strong>Rainbow Gum has no actual concept of named "Loggers"</strong> but a route from a router is the closest analog.

<p>
  When configuring routers you are configuring
  {@link io.jstach.rainbowgum.LevelResolver Level Resolvers} which are logger names to levels 
  and which publisher to use. We call this configuration a "route". As discussed later on
  a publisher has appenders and appenders have outputs thus 
  an important consequnce of this is if you want outputs to have different level thresholds
  (e.g. a debug.log and an error.log) you will need multiple routers. 
</p>

<h3 id="level_resolvers">Level Resolvers</h3>

As mentioned previously routers have a level resolver. A level resolver simply resolves
the {@linkplain java.lang.System.Logger.Level level} (an enum) from a logger name (String).
Because of {@link io.jstach.rainbowgum.LevelResolver} functional interface we can chain them
with <em>fallbacks</em>. An important fallback level resolver that almost all routers use
is the global level resolver. These levels can be configured with 
{@link io.jstach.rainbowgum.LogProperties properties} where logger names prefixed with 
{@value io.jstach.rainbowgum.LogProperties#LEVEL_PREFIX} as the key and the level as the value.
Below is an example:

{@snippet lang=properties :
logging.level.com.mycompany.stuff=DEBUG
logging.level.com.mycompany=INFO
logging.level=ERROR
}

Most level resolvers including the global follow an inheritance or prefix model where 
<code>com.mycompany.stuff.foo</code> will resolve to <code>DEBUG</code>
and <code>com.mycompany.bar</code> will resolve to <code>INFO</code>
and anything not prefixed with <code>com.mycompany</code> will resolve to <code>ERROR</code>.
<p>
  An important consideration is that Rainbow Gum
  <strong>
    by default assumes Level Resolvers are cached or static and will never change.
  </strong>
  This is a critical feature of Rainbow Gum as it <em>allows facade loggers like in SLF4J to be 
  lower overhead than almost all other logging frameworks!</em>
  That being said RainbowGum allows levels to be changed if the backing configuration framework
  supports reloading and the logger name is allowed to be changed.
</p>


{@snippet lang=properties :
logging.global.change=true          # this is required to turn on level changing. 
logging.change.com.mycompany=true   # only logger names starting with com.mycompany can have their levels changed.
}


<h2 id="publishers">Publishers</h2>

A {@link io.jstach.rainbowgum.LogPublisher} basically schedules delivery of a {@link io.jstach.rainbowgum.LogEvent} to a group of 
Appenders. Publishers come in two types: synchronous and asynchronous. An appender should only
belong to one publisher. In other logging frameworks like Logback and Reload4J this responsibility is handled
by an Appender but Rainbow Gum separates this responsibility out.

<h2 id="appenders">Appenders</h2>

An {@linkplain io.jstach.rainbowgum.LogAppender appender} contains an {@linkplain io.jstach.rainbowgum.LogEncoder Encoder} 
and an {@link io.jstach.rainbowgum.LogOutput Output}.
Unlike other logging frameworks it is rare to have custom Appenders as most of the work is done by the encoder and output.
That is an appender can be mostly thought of as a tuple of encoder and output.

<h2 id="encoders">Encoders</h2>

Encoders encode an event into binary. Because most encoding is text based RainbowGum has the concept of 
{@link io.jstach.rainbowgum.LogFormatter} which can be turned into an Encoder. Log formatters
are the most common extension point. 

<h3 id="Formatters">Formatters</h3>

Besides adjusting level configuration the most common configuration is formatting of log events as textual data.
{@link io.jstach.rainbowgum.LogFormatter}s are designed to do just that. While formatters can at highlevel be considered
an encoder for technical API reasons they are not. However any formatter can be converted to an
encoder with {@link io.jstach.rainbowgum.LogEncoder#of(io.jstach.rainbowgum.LogFormatter)}. 
<p>
  For those coming from Logback or Log4j2 
  Rainbow Gum has an {@linkplain io.jstach.rainbowgum.pattern/ optional module} for logback style
  based pattern formatters. This allows describing an output format using 
  <code>String.format</code> percent style syntax. Rainbow Gum implements most of the builtin logback
  pattern keywords with far less overhead. 
</p>
<p>
  Rainbow Gum also has support for proper cross platform {@linkplain io.jstach.rainbowgum.jansi/ ANSI output with Jansi through an optional module}.
  Unlike other frameworks where this is detected with reflection Rainbow Gum uses the 
  Service Loader which is GraalVM native friendly.
</p>
<h2 id="installation">Installation</h2>


<h3 id="maven">Maven</h3>


<pre class="language-xml">
{@code
<properties>
    <rainbowgum.version>_VERSION_</rainbowgum.version>
</properties>
...
<dependencies>
    <dependency>
        <groupId>io.jstach.rainbowgum</groupId>
        <artifactId>rainbowgum</artifactId>
        <version>${rainbowgum.version}</version>
        <scope>runtime</scope>
    </dependency>
</dependencies>
}
</pre>


If you plan on configuring Rainbow Gum programmatically you will need to make a module and create a
service loader registration. In that case you will want the dependency like:

<pre class="language-xml">
{@code
<properties>
    <rainbowgum.version>_VERSION_</rainbowgum.version>
</properties>
...
<dependencies>
    <dependency>
        <groupId>io.jstach.rainbowgum</groupId>
        <artifactId>rainbowgum-core</artifactId>
        <version>${rainbowgum.version}</version>
        <scope>compile</scope>
    </dependency>
</dependencies>
}
</pre>

<h3 id="3.2">Gradle</h3>

<pre><code class="language-kotlin">
dependencies {
    
    runtimeOnly 'io.jstach.rainbowgum:rainbowgum:_VERSION_'
}
</code>
</pre>


If you plan on configuring Rainbow Gum programmatically you will need to make a module and create a
service loader registration. In that case you will want the dependency like:

<pre><code class="language-kotlin">
dependencies {
    
    implementation 'io.jstach.rainbowgum:rainbowgum-core:_VERSION_'
}
</code>
</pre>

<h2 id="configuration">Configuration</h2>

Most configuration of Rainbow Gum is done by adding extension jars as runtime dependencies
or by setting key values in {@linkplain io.jstach.rainbowgum.LogProperties properties}.

By default Rainbow Gum uses System properties for properties but a configuration system
can be used instead.

Logger levels and output can be configured through properties.

More information on builtin properties is in  {@link io.jstach.rainbowgum.LogProperties}.

IF you would like use your own properties system see {@link io.jstach.rainbowgum.spi.RainbowGumServiceProvider}.

<h2 id="integration">Extensions and Integrations</h2>


<h3 id="springframework">Spring Framework</h3>

<h2 id="FAQ">FAQ</h2>

<h3 id="faq_editdoc">There is a typo in this documentation how can I fix it?</h3>

If you would like to make corrections please
file an issue or even better fork, edit, PR this file: 
<pre><a href="https://github.com/jstachio/rainbowgum/blob/main/doc/overview.html">doc/overview.html</a></pre>

<h3 id="faq_javadoc">Where is the Javadoc?</h3>

<em>Shockingly this document is the Javadoc!</em> To be precise it is the aggregate javadoc 
<code>overview.html</code>. 

The modules javadocs should be at the bottom of this document and the search bar at the top can be
used to find documented classes.

<br/>
</div>

</body>
</html>
